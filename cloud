#!/usr/bin/env python3
# cloud - sync local directory with cloud service using rclone

import datetime
import getpass
import os
import socket
import sys
import datetime
import glob
import configparser
from pathlib import Path

def main():
    global CLOUDDATAPATH
    global LOGFILEPATH
    global LOGFILE

    print()
    print(f'{sys.argv[0]} - version 20210130-R1')

    config_file = Path.home() / '.config/cloud/cloud.conf'
    check_file_exists(config_file)
    config = configparser.ConfigParser()
    config.read(config_file)

    primary_data_dir   = config['primary']['local_data_dir']
    primary_log_dir    = config['primary']['local_log_dir']
    CLOUDDATAPATH = Path.home() / primary_data_dir 
    check_path_exists(CLOUDDATAPATH)
    #CLOUDDATAPATH.mkdir(parents=True, exist_ok=True)
    LOGFILEPATH   = Path.home() / primary_log_dir 
    check_path_exists(LOGFILEPATH)
    #LOGFILEPATH.mkdir(parents=True, exist_ok=True)
    LOGFILE = LOGFILEPATH / 'sync_log.txt'
    check_file_exists(LOGFILE)

    accounts = []
    config_sections = config.sections()

    for i in range(1, len(config_sections)):
        label = config_sections[i]
        local_data_dir = config[label]['local_data_dir']
        remote_data_dir = config[label]['remote_data_dir']
        accounts.append([label, str(CLOUDDATAPATH / local_data_dir), remote_data_dir])

    if len(sys.argv) == 2:
        action = sys.argv[1]
        if action == 'push' or action == 'pull':
            perform(action, accounts)
            status()
        if action == 'status':
            status()
    else:
        usage()
    print()

def perform(action, accounts):
    label, local, remote  = 0, 1, 2
    for i in range(len(accounts)):
        header(accounts[i][label])
        if action == 'push':
            cmd = f'rclone sync {accounts[i][local]} {accounts[i][remote]} --progress'
        if action == 'pull':
            cmd = f'rclone sync {accounts[i][remote]} {accounts[i][local]} --progress'
        print(cmd)
        os.system(cmd)
    date = datetime.datetime.now()
    update_log_file(action, date)

def status():
    header('sync log')
    cmd = f'rclone sync box:sync_log {LOGFILEPATH}'
    print(cmd)
    os.system(cmd)

    header('remote file status')
    with open(LOGFILE) as logf:
        content = logf.read().splitlines()
    count = len(content)
    print(f'last action : {content[count-1][:45]}')
    print(f'newest file : {content[count-1][48:]}')

    header('local file status')
    print(f'last push   : {last_push_time()}')
    print(f'newest file : {newest_file_time()}')

    if newest_file_time() > last_push_time():
        print()
        print('push needed...')
    if latest_remote_file_time() > newest_file_time():
        print()
        print('pull needed...')

def update_log_file(action, date):
    os.system(f'rclone sync box:sync_log {LOGFILEPATH}')
    with open(LOGFILE, 'a') as logf:
        actionstring = str(date)[:22] + ' '
        actionstring += action + ' '
        actionstring += getpass.getuser() + '@' + socket.gethostname() + ' '
        newestfilestring = newest_file_time() 
        logstring = f'{actionstring:45} : {newestfilestring}\n'
        logf.write(logstring)
    os.system(f'rclone sync {LOGFILEPATH} box:sync_log')

def last_push_time():
    lastpushtime=''
    with open(LOGFILE) as f:
        content = f.readlines()
    l = len(content)
    for i in range(l):
        words = content[l-1-i].split()
        if words[2] == 'push':
            lastpushtime = words[0] + ' ' + words[1]
            break
    return lastpushtime

def latest_remote_file_time():
    latestfiletime = ''
    with open(LOGFILE) as f:
        content = f.readlines()
    l = len(content)
    words = content[l-1].split()
    colonindex = words.index(':')
    latestfiletime = words[colonindex+1] + ' ' + words[colonindex+2]
    return latestfiletime

def newest_file_time():
    os.chdir(CLOUDDATAPATH)
    gfiles = sorted(glob.glob(str(CLOUDDATAPATH / '**/*'), recursive = True), key=os.path.getmtime)    
    newest = gfiles[-1]
    newest_epoch_time = os.path.getmtime(newest)
    newesttimeandname = formatted_time(newest_epoch_time) + ' ' + newest
    return newesttimeandname

def formatted_time(epoch_time):
    ftime = datetime.datetime.fromtimestamp(epoch_time).strftime('%Y-%m-%d %H:%M:%S.%f')
    return ftime[:22]

def header(label):
    print()
    buffer = f'--- {label} ---'
    buffer = buffer.rjust(80, '-')
    print(buffer.upper())

def check_path_exists(fullpath):
    if not fullpath.is_dir():
        print (f'{fullpath} doesn\'t exist')
        sys.exit()

def check_file_exists(filepath):
    if not filepath.is_file():
        print (f'{filepath} doesn\'t exist')
        sys.exit()

def usage():
    print()
    print('usage:')
    print('    cloud status')
    print('    cloud push')
    print('    cloud pull')
    print()

if __name__ == '__main__':
    main()
    
